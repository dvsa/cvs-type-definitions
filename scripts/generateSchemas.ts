import {
  mkdirSync,
  readFileSync,
  readdirSync,
  rmSync,
  writeFileSync,
} from "fs";

const json2ts = require("json-schema-to-typescript");
const derefSchema = require("json-schema-deref-sync");
const prettyJs = require("pretty-js");

const jsonSchemaDirName = "json-schemas";
const typesDirName = "types";
const definitionsDirName = "json-definitions";

const options = {
  indent: "\t",
  newline: "\r\n",
  quoteProperties: "true",
};

async function generateTypescriptInterface(schemaLocation: string) {
  const saveToLocation = schemaLocation
    .replace(definitionsDirName, typesDirName)
    .replace(".json", ".d.ts");
  const types = await json2ts.compileFromFile(schemaLocation, {
    unreachableDefinitions: true,
    enableConstEnums: false
  });
  writeFile(saveToLocation, types);
  console.log(
    `********** types generated for ${schemaLocation} and saved to ${saveToLocation} **********`
  );
}

function deReferenceJsonSchema(schemaLocation: string): void {
  const derefSchemaPath = schemaLocation.replace(
    definitionsDirName,
    jsonSchemaDirName
  );
  const originalSchema = require(schemaLocation);
  const baseFolder = schemaLocation.substring(
    0,
    schemaLocation.lastIndexOf("/")
  );
  const deReferencedJsonSchema = derefSchema(originalSchema, {
    baseFolder: baseFolder,
  });
  const deReferencedSchema = prettyJs(
    JSON.stringify(deReferencedJsonSchema),
    options
  );
  writeFile(derefSchemaPath, deReferencedSchema);
}

function writeFile(path: string, data: string) {
  const baseFolder = path.substring(0, path.lastIndexOf("/"));
  mkdirSync(baseFolder, { recursive: true });
  writeFileSync(path, data, "utf8");
}

function sanitiseFolders() {
  try {
    sanitiseTypesFolder(typesDirName);
  } catch {}
  try {
    rmSync(jsonSchemaDirName, { recursive: true });
  } catch {}
}

const isFolder = (name: string) => !name.includes(".");

function generateTypesAndSchemaInFolder(path: string, schemasPath: string[]) {
  const folderContents = readdirSync(path, "utf-8");
  folderContents.forEach((item) => {
    const definitionFullPath = `${path}/${item}`;
    if (isFolder(item)) {
      generateTypesAndSchemaInFolder(definitionFullPath, schemasPath);
    } else if (!item.includes(".ignore")) {
      deReferenceJsonSchema(definitionFullPath);
      generateTypescriptInterface(definitionFullPath);
      const removedRootFolder = definitionFullPath.substring(
        definitionFullPath.indexOf("/") + 1
      );
      schemasPath.push(removedRootFolder);
    }
  });
  return schemasPath;
}

function sanitiseTypesFolder(directory: string, files: string[] = []) {
  const contents = readdirSync(directory);
  contents.forEach(async (f) => {
    const name = `${directory}/${f}`;
    if (isFolder(name)) {
      sanitiseTypesFolder(name, files);
    } else {
      const contents = readFileSync(name, { encoding: "utf-8" });
      if (
        contents.includes(
          "This file was automatically generated by json-schema-to-typescript"
        )
      ) {
        rmSync(name);
      }
    }
  });
}

// Defines and maintains an array of valid json schemas for type-safe runtime validation
function generateSchemasArray(paths: string[]) {
  const schemas = `export const schemas = [
  "${paths.join('",\n  "')}",\n] as const;\n`;
  writeFileSync("./schemas.ts", schemas);
}
/**
 * Generate typescript files from json definitions
 */
sanitiseFolders();
const schemas: string[] = [];
generateTypesAndSchemaInFolder(definitionsDirName, schemas);
generateSchemasArray(schemas);
